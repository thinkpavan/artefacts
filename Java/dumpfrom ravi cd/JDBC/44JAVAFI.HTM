<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">





<HTML>





<HEAD>





   <AUTHOR>Joseph Weber</AUTHOR>

   <PUBDATE>November 1996</PUBDATE>

   <TITLE>Special Edition Using Java, Second Edition - Chapter 45</TITLE>

   <ISBN>0-7897-0936-8</ISBN>

   <SUBJECT>Internet Programming</SUBJECT>

   <KEYWORDS>computer programming Internet Java applets JavaScript HTML World Wide Web HotJava AWT JDK</KEYWORDS>

   <ABSTRACT>This book provides extensive coverage of Java and building dynamic applets with Java.</ABSTRACT>



   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (Win95; I) [Netscape]">





</HEAD>





<BODY BGCOLOR="#FFFFFF"><h5 align=center>&nbsp;- Special Edition Using Java, 2nd Edition -</h5><p><img src="que_sq.gif"border=0 height=81 width=108 align=bottom></p>











<H2><B>Chapter 45</B></H2>











<H2><B>JDBC</B></H2>











<P>





<HR ALIGN=CENTER></P>











<P><I>by Krishna Sankar</I></P>











<P>JDBC is a Java database connectivity API that is a part of the Java





Enterprise APIs from JavaSoft. From a developer's point of view, JDBC is





the first standardized effort to integrate relational databases with Java





programs. JDBC has opened all the relational power that can be mustered





to Java applets and applications. In the next two chapters, you take an





in-depth look at the JDBC classes and methods.</P>











<UL>





<LI><B>JDBC overview<BR>





</B>This section describes the history, progression, and current status





of the JDBC specification. An introduction to the inner workings of JDBC





and an explanation of the JDBC security model is also presented.</LI>











<LI><B>JDBC implementation<BR>





</B>As overview of the JDBC classes, the development of the JDBC application





with the JDBC-ODBC bridge and the program flow for a JDBC database interaction





is described in this section.</LI>











<LI><B>JDBC classes<BR>





</B>You find in-depth coverage of the Connection, MetaData, SQLWarning,





and SQLException classes in this section.</LI>





</UL>











<H2><B>JDBC Overview</B></H2>











<P>JDBC is Java database connectivity-, a set of relational database objects





and methods for interacting with data sources. The JDBC APIs are part of





the Enterprise APIs specified by JavaSoft and thus are a part of all Java





Virtual Machine (JVM) implementations.</P>











<BLOCKQUOTE>





<P><IMG SRC="tip.gif" HEIGHT=35 WIDTH=399></P>











<P>Even though the objects and methods are based on the Relational Database





model, JDBC makes no assumption about the underlying data source or the





data storage scheme. You can access and retrieve audio or video data from





many sources and load into Java objects using the JDBC APIs! The only requirement





is that there should be a JDBC implementation for that source.</P>











<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>





</BLOCKQUOTE>











<P>JavaSoft introduced the JDBC API specification in March 1996 as draft





Version 0.50 and was open for public review. The specification went from





Version 0.50 to 0.60 to 0.70 and now is frozen at Version 1.0 dated June





12, 1996. The JDBC Version 1.0 specification available at <B><A HREF="http://splash.javasoft.com/jdbc/">http://splash.javasoft.com/jdbc/</A></B>





(jdbc.100.ps or jdbc.100.pdf) includes all of the improvements from the





four months of review by vendors, developers, and the general public.</P>











<P>Now let's look at the origin and design philosophies. The JDBC designers





based the API on X/Open SQL Call Level Interface (CLI). It is not coincidental





that ODBC is also based on the X/Open CLI. The JavaSoft engineers wanted





to gain leverage from the existing ODBC implementation and development





expertise, thus making it easier for Independent Software Vendors (ISVs)





and system developers to adopt JDBC. But ODBC is a C interface to DBMSes





and thus is not readily convertible to Java. So JDBC design followed ODBC





in spirit as well in its major abstractions and implemented the SQL CLI





with "a Java interface that is consistent with the rest of the Java system,"





as the JDBC specification describes it in Section 2.4. For example, instead





of the ODBC SQLBindColumn and SQLFetch to get column values from the result,





JDBC used a simpler approach (which you learn about later in this chapter).</P>











<H3><A NAME="I6"></A><B>How Does JDBC Work?</B></H3>











<P>As I have discussed, JDBC is designed upon the CLI model. JDBC defines





a set of API objects and methods to interact with the underlying database.





A Java program first opens a connection to a database, makes a statement





object, passes SQL statements to the underlying DBMS through the statement





object, and retrieves the results as well as information about the result





sets. Typically, the JDBC class files and the Java applet/application reside





in the client. They could be downloaded from the network also. To minimize





the latency during execution, it is better to have the JDBC classes in





the client. The Database Management System (DBMS) and the data source are





typically located in a remote server. </P>











<P>Figure 45.1 shows the JDBC communication layer alternatives. The applet/application





and the JDBC layers communicate in the client system, and the driver takes





care of interacting with the database over the network.</P>











<P><BR>





<B><a href="45fig-01.gif">FIG. 45.1</a></B> </P>











<P><I>JDBC Database Communication layer alternatives. The JDBC driver can





be a native library, like the JDBC-ODBC bridge, or a Java class talking





across the network to a RPC or HTTP listener process in the database server.</I></P>











<P>The JDBC classes are in the java.sql package, and all Java programs





use the objects and methods in the java.sql package to read from and write





to data sources. A program using the JDBC will need a driver for the data





source with which it wants to interface. This driver can be a native module





(like the JDBCODBC.DLL for the Windows JDBC-ODBC Bridge developed by Sun/Intersolv),





or it can be a Java program that talks to a server in the network using





some RPC or a HTTP talker-listener protocol. Both schemes are shown in





figure 45.1.</P>











<P>It is conceivable that an application will deal with more than one data





source-possibly heterogeneous data sources. (A Database Gateway Program





is a good example of an application that accesses multiple heterogeneous





data sources.) For this reason, JDBC has a DriverManager whose function





is to manage the drivers and provide a list of currently loaded drivers





to the application programs.</P>











<BLOCKQUOTE>





<P><IMG SRC="sidebar.gif" HEIGHT=35 WIDTH=399></P>











<CENTER><P><BQ ALIGN="CENTER"></P></CENTER>











<CENTER><P><I>Data Source, Database, or DBMS?</I></P></CENTER>











<P></BQ></P>











<P>Even though the word <I>database</I> is in the name JDBC, the form,





content, and location of the data is immaterial to the Java program using





JDBC so long as there is a driver for that data. Hence the notation data





source to describe the data is more accurate than Database, DBMS, DB, or





just file. In the future, Java devices such as televisions, answering machines,





or network computers will access, retrieve, and manipulate different types





of data (audio, video, graphics, time series, and so on) from various sources





that are not relational databases at all! And much of the data might not





even come from mass storage. For example, the data could be video stream





from a satellite or audio stream from a telephone.</P>











<P>ODBC also refers to data sources rather than databases when describing





in general terms.</P>











<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>





</BLOCKQUOTE>











<H3><A NAME="I7"></A><B>Security Model</B></H3>











<P>Security is always an important issue, especially when databases are





involved. As of the writing of this book, JDBC follows the standard security





model in which applets can connect only to the server from where they are





loaded; remote applets cannot connect to local databases. Applications





have no connection restrictions. For pure Java drivers, the security check





is automatic, but for drivers developed in native methods, the drivers





must have some security checks.</P>











<BLOCKQUOTE>





<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>











<P>With Java 1.1 and the Java Security API, you have the ability to establish





"trust relationships" which allows you to verify trusted sites. Then you





could give applets downloaded from trusted sources more functionality by





giving them access to local resources. For more information on Java security,





refer to Chapter 34, "Java Security in Depth".</P>











<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>





</BLOCKQUOTE>











<H3><A NAME="I8"></A><B>JDBC-ODBC Bridge</B></H3>











<P>As a part of JDBC, JavaSoft also will deliver a driver to access ODBC





data sources from JDBC. This driver is jointly developed with Intersolv





and is called the JDBC-ODBC bridge. The JDBC-ODBC bridge is implemented





as the JdbcOdbc.class and a native library to access the ODBC driver. For





the Windows platform, the native library is a DLL (JDBCODBC.DLL).</P>











<P>As JDBC is close to ODBC in design, the ODBC bridge is a thin layer





over JDBC. Internally, this driver maps JDBC methods to ODBC calls and





thus interacts with any available ODBC driver. The advantage of this bridge





is that now JDBC has capability to access almost all databases, as ODBC





drivers are widely available. You can use this bridge (Version 1.0005)





to run the example programs in this and the next chapter.</P>











<H2><A NAME="I9"></A><B>JDBC Implementation</B></H2>











<P>JDBC is implemented as the java.sql package. This package contains all





of the JDBC classes and methods, as shown in table 45.1.</P>











<P><I>Table 45.1 JDBC Classes</I></P>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD><B>Type</B></TD>











<TD><B>Class</B></TD>





</TR>











<TR>





<TD>Driver</TD>











<TD>java.sql.Driver





<P>java.sql.DriverManager</P>











<P>java.sql.DriverPropertyInfo</P>





</TD>





</TR>











<TR>





<TD>Connection</TD>











<TD>java.sql.Connection</TD>





</TR>











<TR>





<TD>Statements</TD>











<TD>java.sql.Statement





<P>java.sql.PreparedStatement</P>











<P>java.sql.CallableStatement </P>





</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>java.sql.ResultSet </TD>





</TR>











<TR>





<TD>Errors/Warning</TD>











<TD>java.sql.SQLException





<P>java.sql.SQLWarning </P>





</TD>





</TR>











<TR>





<TD>MetaData</TD>











<TD>java.sql.DatabaseMetaData





<P>java.sql.ResultSetMetaData</P>





</TD>





</TR>











<TR>





<TD>Date/Time</TD>











<TD>java.sql.Date





<P>java.sql.Time</P>











<P>java.sql.Timestamp </P>





</TD>





</TR>











<TR>





<TD>Misc.</TD>











<TD>java.sql.Numeric





<P>java.sql.Types</P>











<P>java.sql.DataTruncation </P>





</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<P>Now look at these classes and see how you can develop a simple JDBC





application.</P>











<H3><A NAME="I10"></A><B>JDBC Classes-Overview</B></H3>











<P>When you look at the class hierarchy and methods associated with it,





the topmost class in the hierarchy is the DriverManager. The DriverManager





keeps the driver information, state information, and more. When each driver





is loaded, it registers with the DriverManager. The DriverManager when





required to open a connection selects the driver depending on the JDBC





URL.</P>











<BLOCKQUOTE>





<P><IMG SRC="sidebar.gif" HEIGHT=35 WIDTH=399></P>











<CENTER><P><BQ ALIGN="CENTER"></P></CENTER>











<CENTER><P><I>JDBC URL</I></P></CENTER>











<P></BQ></P>











<P>True to the nature of the Internet, JDBC identifies a database with





a URL. The URL is of the form </P>











<BLOCKQUOTE>





<LI><B>jdbc:&lt;<I>subprotocol</I>&gt;:&lt;<I>subname related to the DBMS/Protocol</I>&gt;</B></LI>





</BLOCKQUOTE>











<P>For databases on the Internet/intranet, the subname can contain the





Net URL <B>//hostname:port/..</B>. The &lt;subprotocol&gt; can be any name





that a database understands. The odbc subprotocol name is reserved for





ODBC style data sources. A normal ODBC database JDBC URL looks like:</P>











<BLOCKQUOTE>





<LI>jdbc:odbc:&lt;ODBC DSN&gt;;User=&lt;username&gt;;PW=&lt;password&gt;</LI>





</BLOCKQUOTE>











<P>If you are developing a JDBC driver with a new subprotocol, it is better





to reserve the subprotocol name with JavaSoft, which maintains an informal





subprotocol registry.</P>











<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>





</BLOCKQUOTE>











<P>The java.sql.Driver class is usually referred to for information such





as PropertyInfo, version number, and so on. So the class could be loaded





many times during the execution of a Java program using the JDBC API.</P>











<P>Looking at the java.sql.Driver and java.sql.DriverManager classes and





methods as listed in table 45.2, you see that the DriverManager returns





a Connection object when you use the getConnection() method.</P>











<P><I>Table 45.2 </I>Driver,DriverManager<I> and related methods</I></P>











<CENTER><P>java.sql.Driver</P></CENTER>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD><B>Return Type</B></TD>











<TD><B>Method Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>Connection</TD>











<TD>connect</TD>











<TD>(String url, java.util.Properties info)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>acceptsURL</TD>











<TD>(String url)</TD>





</TR>











<TR>





<TD>DriverPropertyInfo[]</TD>











<TD>getPropertyInfo</TD>











<TD>(String url, java.util.Properties info)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMajorVersion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMinorVersion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>jdbcCompliant</TD>











<TD>()</TD>





</TR>











<TR>





<TD COLSPAN=3>





<CENTER><P>java.sql.DriverManager</P></CENTER>





</TD>





</TR>











<TR>





<TD>Connection</TD>











<TD>getConnection</TD>











<TD>(String url, java.util.Properties info)</TD>





</TR>











<TR>





<TD>Connection</TD>











<TD>getConnection</TD>











<TD>(String url, String user, String password)</TD>





</TR>











<TR>





<TD>Connection</TD>











<TD>getConnection</TD>











<TD>(String url)</TD>





</TR>











<TR>





<TD>Driver</TD>











<TD>getDriver</TD>











<TD>(String url)</TD>





</TR>











<TR>





<TD>void</TD>











<TD>registerDriver</TD>











<TD>(java.sql.Driver driver)</TD>





</TR>











<TR>





<TD>void</TD>











<TD>deregisterDriver</TD>











<TD>(Driver driver)</TD>





</TR>











<TR>





<TD>java.util.Enumeration</TD>











<TD>getDrivers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setLoginTimeout</TD>











<TD>(int seconds)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getLoginTimeout</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setLogStream</TD>











<TD>(java.io.PrintStream out)</TD>





</TR>











<TR>





<TD>java.io.PrintStream</TD>











<TD>getLogStream</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void </TD>











<TD>println</TD>











<TD>(String message)</TD>





</TR>











<TR>





<TD COLSPAN=3>





<CENTER><P><I>Class initialization routine</I></P></CENTER>





</TD>





</TR>











<TR>





<TD><B>Return Type</B></TD>











<TD><B>Method Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>void </TD>











<TD>initialize</TD>











<TD>()</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<P>Other useful methods include the registerDriver(), deRegister(), and





getDrivers() methods. By using the getDrivers() method, you can get a list





of registered drivers. Figure 45.2 shows the JDBC class hierarchy as well





as the flow of a typical Java program using the JDBC APIs.</P>











<P>In the next subsection, let's follow the steps required to access a





simple database access using JDBC and the JDBC-ODBC driver.</P>











<H3><A NAME="I11"></A><B>Anatomy of a JDBC Application</B></H3>











<P>To handle data from a database, a Java program follows the following





general steps. Figure 45.2 shows the general JDBC objects, the methods,





and the sequence. First, the program calls the getConnection() method to





get the Connection object. Then it creates the Statement object and prepares





a SQL statement.</P>











<P><BR>





<B><a href="45fig-02.gif">FIG. 45.2</A></B> </P>











<P><I>JDBC class hierarchy and a JDBC API flow.</I></P>











<P>A SQL statement can be executed immediately (Statement object), or can





be a compiled statement (PreparedStatement object) or a call to a stored





procedure (CallableStatement object). When the method executeQuery() is





executed, a ResultSet object is returned. SQL statements such as update





or delete will not return a ResultSet. For such statements, the executeUpdate()





method is used. The executeUpdate() method returns an integer which denotes





the number of rows affected by the SQL statement.</P>











<P>The ResultSet contains rows of data that is parsed using the next()





method. In case of a transaction processing application, methods such as





rollback() and commit() can be used either to undo the changes made by





the SQL statements or permanently affect the changes made by the SQL statements.</P>











<H3><A NAME="I12"></A><B>JDBC Examples</B></H3>











<P>These examples access the Student database, the schema of which is shown





in figure 45.3. The tables in the examples that you are interested in are





the Students Table, Classes Table, Instructors table, and Students_Classes





table. This database is a Microsoft Access database. The full database





and sample data is generated by the Access Database Wizard. You access





the database using JDBC and the JDBC-ODBC bridge (Beta Version 1.0005).</P>











<P><BR>





<B><A HREF="figs/42fig03.gif">FIG. 45.3</A></B> </P>











<P><I>JDBC example database schema.</I></P>











<P>Before you jump into writing a Java JDBC program, you need to configure





an ODBC data source. As you saw earlier, the getConnection() method requires





a data source name (DSN), user ID, and password for the ODBC data source.





The database driver type or subprotocol name is odbc. So the driver manager





finds out from the ODBC driver the rest of the details. </P>











<P>But wait, where do you put the rest of the details? This is where the





ODBC setup comes into the picture. The ODBC Setup program runs outside





the Java application from the Microsoft ODBC program group. The ODBC Setup





program allows you to set up the data source so that this information is





available to the ODBC Driver Manager, which in turn loads the Microsoft





Access ODBC driver. If the database is in another DBMS form-say, Oracle-you





configure this source as Oracle ODBC driver. In the Windows 3.x, the Setup





program puts this information in the ODBC.INI file. With Windows 95 and





Windows NT 4.0, this information is in the Registry. Figure 45.4 shows





the ODBC setup screen.</P>











<P><BR>





<B><A HREF="figs/42fig04.gif">FIG. 45.4</A></B> </P>











<P><I>ODBC Setup for the Example database. After this setup, the example





database URL is jdbc:odbc:StudentDB;uid="admin";pw="sa".</I></P>











<H4><B>JDBC Query Example</B></H4>











<P>In this example, you list all of the students in the database by a SQL





SELECT statement. The steps required to accomplish this task using the





JDBC API are listed here. For each step, the Java program code with the





JDBC API calls follows the description of the steps.</P>











<PRE><TT><FONT COLOR="#238E23">   //Declare a method and some variables.





   public void ListStudents() throws SQLException {





int i, NoOfColumns;





String StNo,StFName,StLName;





      //Initialize and load the JDBC-ODBC driver.





Class.forName (&quot;jdbc.odbc.JdbcOdbcDriver&quot;);





      //Make the connection object.





Connection Ex1Con = DriverManager.getConnection( &quot;jdbc:odbc:StudentDB;uid="admin";pw="sa");





//Create a simple Statement object.





Statement Ex1Stmt = Ex1Con.createStatement();





//Make a SQL string, pass it to the DBMS, and execute the SQL statement.





ResultSet Ex1rs = Ex1Stmt.executeQuery(





&quot;SELECT StudentNumber, FirstName, LastName FROM Students&quot;);





//Process each row until there are no more rows.





      // Displays the results on the console.





System.out.println("Student Number        First Name      Last Name");





while (Ex1rs.next()) {





// Get the column values into Java variables





StNo = Ex1rs.getString(1);





StFName = Ex1rs.getString(2);





StLName = Ex1rs.getString(3);





System.out.println(StNo,StFName,StLName);





}





}</FONT></TT></PRE>











<P>As you can see, it is a simple Java program using the JDBC API. The





program illustrates the basic steps that are needed to access a table and





lists some of the fields in the records.</P>











<H4><B>JDBC Update Example</B></H4>











<P>In this example, you update the FirstName field in the Students table





by knowing the student's StudentNumber. As in the last example, the code





follows the description of the step.</P>











<PRE><TT><FONT COLOR="#238E23">   //Declare a method and some variables and parameters.





public void UpdateStudentName(String StFName, String StLName,





String StNo) throws SQLException {





int RetValue;





      // Initialize and load the JDBC-ODBC driver.





Class.forName (&quot;jdbc.odbc.JdbcOdbcDriver&quot;);





// Make the connection object.





Connection Ex1Con = DriverManager.getConnection( &quot;jdbc:odbc:StudentDB;uid="admin";pw="sa");





// Create a simple Statement object.





Statement Ex1Stmt = Ex1Con.createStatement();





//Make a SQL string, pass it to the DBMS, and execute the SQL statement





String SQLBuffer = &quot;UPDATE Students SET FirstName = "+





StFName+", LastName = "+StLName+





" WHERE StudentNumber = "+StNo





RetValue = Ex1Stmt.executeUpdate( SQLBuffer);





System.out.println(&quot;Updated &quot; + RetValue + &quot; rows in the Database.&quot;);





}</FONT></TT></PRE>











<P>In this example, you execute the SQL statement and get the number of





rows affected by the SQL statement back from the DBMS.</P>











<P>The previous two examples show how you can do simple yet powerful SQL





manipulation of the underlying data using the JDBC API in a Java program.





In the following sections, you examine each JDBC class in detail.</P>











<H2><A NAME="I13"></A><B>The <I>Connection</I> Class</B></H2>











<P>The Connection class is one of the major classes in JDBC. It packs a





lot of functionality, ranging from transaction processing to creating statements,





in one class as seen in table 45.3.</P>











<P><I>Table 45.3 </I>java.sql.Connection<I> Methods and Constants</I></P>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD COLSPAN=3>





<CENTER><P><I>Statement-Related Methods</I></P></CENTER>





</TD>





</TR>











<TR>





<TD><B>Return Type</B></TD>











<TD><B>Method Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>Statement</TD>











<TD>createStatement</TD>











<TD>()</TD>





</TR>











<TR>





<TD>PreparedStatement</TD>











<TD>prepareStatement</TD>











<TD>(String sql)</TD>





</TR>











<TR>





<TD>CallableStatement</TD>











<TD>prepareCall</TD>











<TD>(String sql)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>nativeSQL</TD>











<TD>(String sql)</TD>





</TR>











<TR>





<TD>void</TD>











<TD>close</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isClosed</TD>











<TD>()</TD>





</TR>











<TR>





<TD COLSPAN=3>





<CENTER><P><I>Metadata-Related Methods</I></P></CENTER>





</TD>





</TR>











<TR>





<TD>DatabaseMetaData</TD>











<TD>getMetaData</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setReadOnly</TD>











<TD>(boolean readOnly)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isReadOnly</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setCatalog</TD>











<TD>(String catalog)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getCatalog</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setAutoClose</TD>











<TD>(boolean autoClose)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>getAutoClose</TD>











<TD>()</TD>





</TR>











<TR>





<TD>SQLWarning</TD>











<TD>getWarnings</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>clearWarnings</TD>











<TD>()</TD>





</TR>











<TR>





<TD COLSPAN=3>





<CENTER><P><I>Transaction-Related Methods</I></P></CENTER>





</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setAutoCommit</TD>











<TD>(boolean autoCommit)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>getAutoCommit</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>commit</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>rollback</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setTransactionIsolation</TD>











<TD>(int level)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getTransactionIsolation</TD>











<TD>()</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<P>The TransactionIsolation constants are defined in the java.sql.Connection





as integers with the following values:</P>











<P><B><I>TransactionIsolation</I> Constant Name Value</B></P>











<P>TRANSACTION_NONE 0 </P>











<P>TRANSACTION_READ_UNCOMMITTED 1</P>











<P>TRANSACTION_READ_COMMITTED 2</P>











<P>TRANSACTION_REPEATABLE_READ 4</P>











<P>TRANSACTION_SERIALIZABLE 8</P>











<P>As you saw earlier, the connection is for a specific database that can





be interacted with in a specific subprotocol. The Connection object internally





manages all aspects about a connection, and the details are transparent





to the program. Actually, the Connection object is a pipeline into the





underlying DBMS driver. The information to be managed includes the data





source identifier, the subprotocol, the state information, the DBMS SQL





execution plan ID or handle, and any other contextual information needed





to interact successfully with the underlying DBMS.</P>











<BLOCKQUOTE>





<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>











<P>The data source identifier could be a port in the Internet database





server that is identified by the <B>//&lt;server name&gt;:port/..</B> URL,





or just a data source name used by the ODBC driver, or a full path name





to a database file in the local computer. For all you know, it could be





a pointer to data feed of the stock market prices from the Wall Street!</P>











<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>





</BLOCKQUOTE>











<P>Another important function performed by the Connection object is the





transaction management. The handling of the transactions depends on the





state of an internal autocommit flag that is set using the setAutoCommit()





method, and the state of this flag can be read using the getAutoCommit()





method. When the flag is true, the transactions are automatically committed





as soon as they are completed. There is no need for any intervention or





commands from the Java application program. When the flag is false, the





system is in the manual mode. The Java program has the option to commit





the set of transactions that happened after the last commit or rollback





the transactions using the commit() and rollback() methods.</P>











<BLOCKQUOTE>





<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>











<P>JDBC also provides methods for setting the transaction isolation modularity.





When we are developing multitiered applications, there will be multiple





users performing concurrently interleaved transactions that are on the





same database tables. A database driver has to employ sophisticated locking





and data buffering algorithms and mechanisms to implement the transaction





isolation required for a large-scale JDBC application. This is more complex





when there are multiple Java objects working on many databases that could





be scattered across the globe! Only time will tell what special needs for





transaction isolation there will be in the new Internet/intranet paradigm.</P>











<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>





</BLOCKQUOTE>











<P>Once you have a successful Connection object to a data source, you can





interact with the data source in many ways. The most common approach from





an application developer standpoint is the objects that handle the SQL





statements. In JDBC, there are three main types of statements: </P>











<BLOCKQUOTE>





<LI>Statement</LI>











<LI>PreparedStatement</LI>











<LI>CallableStatement</LI>





</BLOCKQUOTE>











<P>The Connection object has the createStatement(), prepareStatement(),





and prepareCall() methods to create these statement objects. Chapter 43





deals with the statement-type objects in detail.</P>











<P>Another notable method in the Connection object is the getMetadata()





method that returns an object of the DatabaseMetaData type, which is the





topic for the following sub-section.</P>











<H2><A NAME="I14"></A><B>MetaData Functions</B></H2>











<P>Strictly speaking theoretically, MetaData is information about data.





The MetaData methods are mainly aimed at the database tools and wizards





that need information about the capabilities and structure of the underlying





DBMS. Many times, these tools need dynamic information about the ResultSet,





which a SQL statement returns. JDBC has two classes of MetaData: ResultSetMetaData





and DatabaseMetadata. As you can see from the method tables, a huge number





of methods are available in this class of objects.</P>











<H3><A NAME="I15"></A><B>DatabaseMetaData</B></H3>











<P>DatabaseMetaData are similar to the catalog functions in ODBC, where





an application queries the underlying DBMS's system tables and gets information.





ODBC returns the information as a result set. JDBC returns the results





as a ResultSet object with well-defined columns.</P>











<P>The DatabaseMetaData object and its methods give a lot of information





about the underlying database. This information is more useful for database





tools, automatic data conversion, and gateway programs. Table 45.4 gives





all of the methods for the DatabaseMetaData object. As you can see, it





is a very long table with more than 100 methods. Unless they are very exhaustive





GUI tools, most of the programs will not use all of the methods. But as





a developer, there will be times when one needs to know some characteristic





about the database or see whether a feature is supported. It is those times





that the following table comes in handy.</P>











<P><I>Table 45.4 DatabaseMetaData methods</I></P>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD><B>Return Type</B></TD>











<TD><B>Method Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>allProceduresAreCallable</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>allTablesAreSelectable</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getURL</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getUserName</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isReadOnly</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>nullsAreSortedHigh</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>nullsAreSortedLow</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>nullsAreSortedAtStart</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>nullsAreSortedAtEnd</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getDatabaseProductName</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getDatabaseProductVersion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getDriverName</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getDriverVersion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getDriverMajorVersion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getDriverMinorVersion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>usesLocalFiles</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>usesLocalFilePerTable</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsMixedCaseIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>storesUpperCaseIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>storesLowerCaseIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>storesMixedCaseIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsMixedCaseQuotedIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>storesUpperCaseQuotedIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>storesLowerCaseQuotedIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>storesMixedCaseQuotedIdentifiers</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getIdentifierQuoteString</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getSQLKeywords</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getNumericFunctions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getStringFunctions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getSystemFunctions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getTimeDateFunctions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getSearchStringEscape</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getExtraNameCharacters</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsAlterTableWithAddColumn</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsAlterTableWithDropColumn</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsColumnAliasing</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>nullPlusNonNullIsNull</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsConvert</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsConvert</TD>











<TD>(int fromType, int toType)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsTableCorrelationNames</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsDifferentTableCorrelation</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Names</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsExpressionsInOrderBy</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsOrderByUnrelated</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsGroupBy</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsGroupByUnrelated</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsGroupByBeyondSelect</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsLikeEscapeClause</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsMultipleResultSets</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsMultipleTransactions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsNonNullableColumns</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsMinimumSQLGrammar</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCoreSQLGrammar</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsExtendedSQLGrammar</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsANSI92EntryLevelSQL</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsANSI92IntermediateSQL</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>upportsANSI92FullSQL</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsIntegrityEnhancement</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Facility</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsOuterJoins</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsFullOuterJoins</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsLimitedOuterJoins</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getSchemaTerm</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getProcedureTerm</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getCatalogTerm</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isCatalogAtStart</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getCatalogSeparator</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSchemasInDataManipulation</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSchemasInProcedureCalls</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSchemasInTableDefinitions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSchemasInIndexDefinitions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSchemasInPrivilege</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Definitions</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCatalogsInDataManipulation</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCatalogsInProcedureCalls</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCatalogsInTableDefinitions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCatalogsInIndexDefinitions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCatalogsInPrivilege</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Definitions</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsPositionedDelete</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsPositionedUpdate</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSelectForUpdate</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsStoredProcedures</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSubqueriesInComparisons</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSubqueriesInExists</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSubqueriesInIns</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsSubqueriesInQuantifieds</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsCorrelatedSubqueries</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsUnion</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsUnionAll</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsOpenCursorsAcrossCommit</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsOpenCursorsAcrossRollback</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean </TD>











<TD>supportsOpenStatementsAcrossCommit</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsOpenStatementsAcross</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Rollback</TD>











<TD></TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxBinaryLiteralLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxCharLiteralLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxColumnNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxColumnsInGroupBy</TD>











<TD>()</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD>int</TD>











<TD>getMaxColumnsInIndex</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxColumnsInOrderBy</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxColumnsInSelect</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxColumnsInTable</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxConnections</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxCursorNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxIndexLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxSchemaNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxProcedureNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxCatalogNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxRowSize</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>doesMaxRowSizeIncludeBlobs</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxStatementLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxStatements</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxTableNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxTablesInSelect</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getMaxUserNameLength</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getDefaultTransactionIsolation</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsTransactions</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsTransactionIsolationLevel</TD>











<TD>(int level) </TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsDataDefinitionAndData</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>ManipulationTransactions</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>supportsDataManipulation</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>TransactionsOnly</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>dataDefinitionCausesTransaction</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Commit</TD>











<TD></TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>dataDefinitionIgnoredIn</TD>











<TD>()</TD>





</TR>











<TR>





<TD></TD>











<TD>Transactions</TD>











<TD></TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getProcedures</TD>











<TD>(String catalog, String schemaPattern, String procedureNamePattern)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getProcedureColumns</TD>











<TD>(String catalog, String schemaPattern, String procedureNamePattern,





String columnNamePattern)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getTables</TD>











<TD>(String catalog, String schemaPattern, String tableNamePattern, String





types[])</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getSchemas</TD>











<TD>()</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getCatalogs</TD>











<TD>()</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getTableTypes</TD>











<TD>()</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getColumns</TD>











<TD>(String catalog, String schemaPattern, String tableNamePattern, String





columnNamePattern)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getColumnPrivileges</TD>











<TD>(String catalog, String schema, String table, String columnNamePattern)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getTablePrivileges</TD>











<TD>(String catalog, String schemaPattern, String tableNamePattern)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getBestRowIdentifier</TD>











<TD>(String catalog, String schema, String table, int scope, boolean nullable)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getVersionColumns</TD>











<TD>(String catalog, String schema, String table)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getPrimaryKeys</TD>











<TD>(String catalog, String schema, String table)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getImportedKeys</TD>











<TD>(String catalog, String schema, String table)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getExportedKeys</TD>











<TD>(String catalog, String schema, String table)</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getCrossReference</TD>











<TD>(String primaryCatalog, String primarySchema, String primaryTable,





String foreignCatalog, String foreignSchema, String foreignTable )</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getTypeInfo</TD>











<TD>()</TD>





</TR>











<TR>





<TD>ResultSet</TD>











<TD>getIndexInfo</TD>











<TD>(String catalog, String schema, String table, boolean unique, boolean





approximate)</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<P>As you can see in the table, the DatabaseMetaData object gives information





about the functionality and limitation of the underlying DBMS. An important





set of information that is very useful for an application programmer includes





the methods describing schema details of the tables in the database, as





well as table names, stored procedure names, and so on.</P>











<P>An example of using the DatabaseMetaData objects from a Java application





is the development of multitier-tier, scaleable applications. A Java application





can query if the underlying database engine supports a particular feature.





If it does not, Java can call alternate methods to perform the task. This





way, the application will not fail if a feature is not available in the





DBMS. </P>











<P>At the same time, the application will exploit advanced functionality





whenever they are available. This is what some experts call "interoperable





and yet scaleable" Interoperability is needed for application tools also-especially





for general-purpose design and query tools based on Java that must interact





with different data sources. These tools have to query the data source





system to find out the supported features and proceed accordingly. The





tools might be able to process information faster with data sources that





support advances features, or they may be able to provide the user with





more options for a feature-rich data source.</P>











<H3><A NAME="I16"></A><B>ResultSetMetaData </B></H3>











<P>Compared to the DatabaseMetaData, the ResultSetMetaData object is easier





and has fewer methods. But these will be more popular with application





developers. The ResultSetMetaData, as the name implies, describes a ResultSet





object. Table 45.5 lists all of the methods available for the ResultSetMetaData





object.</P>











<P><I>Table 45.5 ResultSetMetaData Methods</I></P>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD><B>Return Type</B></TD>











<TD><B>Method Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>Int</TD>











<TD>getColumnCount</TD>











<TD>()</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isAutoIncrement</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isCaseSensitive</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isSearchable</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean </TD>











<TD>isCurrency</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>isNullable</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isSigned</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getColumnDisplaySize</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getColumnLabel</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getColumnName</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getSchemaName</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getPrecision</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getScale</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getTableName</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getCatalogName</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getColumnType</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getColumnTypeName</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isReadOnly</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isWritable</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD>boolean</TD>











<TD>isDefinitelyWritable</TD>











<TD>(int column)</TD>





</TR>











<TR>





<TD COLSPAN=3>





<CENTER><P><I>Return Values</I></P></CENTER>





</TD>





</TR>











<TR>





<TD COLSPAN=3>int columnNoNulls = 0</TD>





</TR>











<TR>





<TD COLSPAN=3>int columnNullable = 1</TD>





</TR>











<TR>





<TD COLSPAN=3>int ColumnNullable Unknown = 2</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<P>As you can see from the previous table, the ResultSetMetaData object





can be used to find out about the types and properties of the columns in





a ResultSet. You need to use methods such as getColumnLabel() and getColumnDisplaySize()





even in normal application programs. Using these methods will result in





programs that handle ResultSets generically, thus assuring uniformity across





various applications in an organization as the names and sizes are taken





form the database itself.</P>











<P>Before you leave this chapter, let's also look at the exception handling





facilities offered by JDBC.</P>











<H2><A NAME="I17"></A><B><I>SQLExceptions</I> Class</B></H2>











<P>The SQLException in JDBC provides a variety of information regarding





errors that occurred during a database access. The SQLException objects





are chained so that a program can read them in order. This is a good mechanism,





as an error condition can generate multiple errors and the final error





might not have anything to do with the actual error condition. By chaining





the errors, we can actually pinpoint the first error. Each SQLException





has an error message and vendor-specific error code. Also associated with





a SQL Exception is a SQLState string that follows the XOPEN SQLState values





defined in the SQL specification. Table 45.6 lists the methods for the





SQLException class.</P>











<P><I>Table 45.6 SQLExceptions Methods</I></P>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD><B>Return Type</B></TD>











<TD><B>Method Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>SQLException</TD>











<TD>SQLException</TD>











<TD>(String reason, String SQLState, int vendorCode)</TD>





</TR>











<TR>





<TD>SQLException</TD>











<TD>SQLException</TD>











<TD>(String reason, String SQLState)</TD>





</TR>











<TR>





<TD>SQLException</TD>











<TD>SQLException</TD>











<TD>(String reason)</TD>





</TR>











<TR>





<TD>SQLException</TD>











<TD>SQLException</TD>











<TD>()</TD>





</TR>











<TR>





<TD>String</TD>











<TD>getSQLState</TD>











<TD>()</TD>





</TR>











<TR>





<TD>int</TD>











<TD>getErrorCode</TD>











<TD>()</TD>





</TR>











<TR>





<TD>SQLException</TD>











<TD>getNextException</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void</TD>











<TD>setNextException</TD>











<TD>(SQLException ex)</TD>





</TR>





</TABLE>





</BLOCKQUOTE>











<H2><A NAME="I18"></A><B><I>SQLWarnings</I> Class</B></H2>











<P>Unlike the SQLExceptions that the program knows have happened because





of raised exceptions, the SQLWarnings do not cause any commotion in a Java





program. The SQLWarnings are tagged to the object whose method caused the





Warning. So you should check for Warnings using the getWarnings() method





that is available for all objects. Table 45.7 lists the methods associated





with the SQLWarnings class.</P>











<P><I>Table 45.7 SQLWarnings Methods</I></P>











<BLOCKQUOTE>





<TABLE BORDER=1 >





<TR>





<TD><B>Return Type</B></TD>











<TD><B>Function Name</B></TD>











<TD><B>Parameter</B></TD>





</TR>











<TR>





<TD>SQLWarning</TD>











<TD>SQLWarning</TD>











<TD>(String reason, String SQLState, int vendorCode)</TD>





</TR>











<TR>





<TD>SQLWarning </TD>











<TD>SQLWarning</TD>











<TD>(String reason, String SQLState)</TD>





</TR>











<TR>





<TD>SQLWarning </TD>











<TD>SQLWarning</TD>











<TD>(String reason)</TD>





</TR>











<TR>





<TD>SQLWarning </TD>











<TD>SQLWarning</TD>











<TD>()</TD>





</TR>











<TR>





<TD>SQLWarning </TD>











<TD>getNextWarning</TD>











<TD>()</TD>





</TR>











<TR>





<TD>void </TD>











<TD>setNextWarning</TD>











<TD>(SQLWarning w)</TD>





</TR>





</TABLE>





</BLOCKQUOTE>





<B><I></I></B>





<br><hr><center><p> | <A href="43javafi.htm"> Previous Chapter </a> | <A href="index.htm"> Table of Contents </a> | <A href="45javafi.htm"> Next Chapter </a> | </p> </center></BODY>





</HTML>









