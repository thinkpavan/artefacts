<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">



<HTML>



<HEAD>



   <AUTHOR>Joseph Weber</AUTHOR>

   <PUBDATE>November 1996</PUBDATE>

   <TITLE>Special Edition Using Java, Second Edition - Chapter 46</TITLE>

   <ISBN>0-7897-0936-8</ISBN>

   <SUBJECT>Internet Programming</SUBJECT>

   <KEYWORDS>computer programming Internet Java applets JavaScript HTML World Wide Web HotJava AWT JDK</KEYWORDS>

   <ABSTRACT>This book provides extensive coverage of Java and building dynamic applets with Java.</ABSTRACT>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (Win95; I) [Netscape]">



</HEAD>



<BODY BGCOLOR="#FFFFFF"><h5 align=center>&nbsp;- Special Edition Using Java, 2nd Edition -</h5><p><img src="que_sq.gif"border=0 height=81 width=108 align=bottom></p>







<H2><B>Chapter 46</B></H2>







<H2><B>JDBC Explored</B></H2>







<P>



<HR ALIGN=CENTER></P>







<P><I>by Krishna Sankar</I></P>







<P>In the last chapter, you saw how JDBC has ushered in an era of simple



yet powerful database access for Java programs. You saw how JDBC works,



and a couple of JDBC examples were presented. In this chapter, you explore



more of JDBC, especially how JDBC handles SQL statements and the variety



of ways we can process the ResultSet it returns.</P>







<UL>



<LI><B>The <TT><FONT COLOR="#238E23">Statement</FONT></TT> classes<BR>



</B>Statements-specifically SQL statements-are the vehicles by which the



application program interacts with the underlying DBMS. JDBC provides three



types of <TT><FONT COLOR="#238E23">Statement</FONT></TT> objects to handle



SQL interaction: <TT><FONT COLOR="#238E23">Statement</FONT></TT>, <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>,



and <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT>.</LI>







<LI><B>The <TT><FONT COLOR="#238E23">ResultSet</FONT></TT> class<BR>



</B>Most of the time, SQL statements return rows and rows of data. The



<TT><FONT COLOR="#238E23">ResultSet</FONT></TT> object provides methods



to handle this data from a Java program.</LI>







<LI><B>Supporting classes<BR>



</B>JDBC provides classes like <TT><FONT COLOR="#238E23">Date</FONT></TT>,



<TT><FONT COLOR="#238E23">Time</FONT></TT>, <TT><FONT COLOR="#238E23">TimeStamp</FONT></TT>,



<TT><FONT COLOR="#238E23">DataTruncation</FONT></TT> and more to handle



various types of situations during the execution of a Java program using



the JDBC API.</LI>







<LI><B>The present and future of JDBC<BR>



</B>This last section wraps up the trilogy of JDBC chapters with a few



observations.</LI>



</UL>







<H2><A NAME="I7"></A><A NAME="I8"></A><B>Statements</B></H2>







<P>The <TT><FONT COLOR="#238E23">Statement</FONT></TT> object does all



of the work to interact with the Database Management System in terms of



SQL statements. You can create many <TT><FONT COLOR="#238E23">Statement</FONT></TT>



objects from one <TT><FONT COLOR="#238E23">Connection</FONT></TT> object.



Internally, the <TT><FONT COLOR="#238E23">Statement</FONT></TT> object



would be storing the various data needed to interact with a database, including



state information, buffer handles, and so on. But these are transparent



to the JDBC application program.</P>







<BLOCKQUOTE>



<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>







<P><BQ></P>







<P>When a program attempts an operation that is not in sync with the internal



state of the system (for example, a <TT><FONT COLOR="#238E23">next()</FONT></TT>



method to get a row when no SQL statements have been executed) this discrepancy



is caught and an exception is raised. This exception, normally, is probed



by the application program using the methods in the <TT><FONT COLOR="#238E23">SQLException</FONT></TT>



object.</P>







<P></BQ></P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>



</BLOCKQUOTE>







<P>JDBC supports three types of statements: </P>







<UL>



<LI><TT><FONT COLOR="#238E23">Statement</FONT></TT></LI>







<LI><TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT></LI>







<LI><TT><FONT COLOR="#238E23">CallableStatement</FONT></TT></LI>



</UL>







<P>Before you explore these different statements, see the steps that a



<TT><FONT COLOR="#238E23">SQL</FONT></TT> statement goes through.</P>







<P>A Java application program first builds the <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statement in a string buffer and passes this buffer to the underlying DBMS



through some API call. A SQL statement needs to be verified syntactically,



optimized, and converted to an executable form before execution. In the



Call Level Interface (CLI) Application Program Interface (API) model, the



application program through the driver passes the SQL statement to the



underlying DBMS, which prepares and executes the SQL statement.</P>







<P>After the DBMS receives the SQL string buffer, it parses the statement



and does a syntax check run. If the statement is not syntactically correct,



the system returns an error condition to the driver, which generates a



<TT><FONT COLOR="#238E23">SQLException</FONT></TT>. If the statement is



syntactically correct, depending on the DBMS, then many query plans usually



are generated that are run through an optimizer (often a cost-based optimizer).



Then, the optimum plan is translated into a binary execution plan. After



the execution plan is prepared, the DBMS usually returns a handle or identifier



to this optimized binary version of the <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statement to the application program.</P>







<P>The three JDBC statement types (<TT><FONT COLOR="#238E23">Statement</FONT></TT>,



<TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>, and <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT>)



differ in the timing of the SQL statement preparation and the statement



execution. In the case of the simple <TT><FONT COLOR="#238E23">Statement</FONT></TT>



object, the SQL is prepared and executed in one step (at least from the



application program point of view. Internally, the driver might get the



identifier, command the DBMS to execute the query, and then discard the



handle). In the case of a <TT><FONT COLOR="#238E23">PreparedStatement object</FONT></TT>,



the driver stores the execution plan handle for later use. In the case



of the <TT><FONT COLOR="#238E23">CallableStatement object</FONT></TT>,



the <TT><FONT COLOR="#238E23">SQL</FONT></TT> statement is actually making



a call to a stored procedure that is usually already optimized.</P>







<BLOCKQUOTE>



<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>







<P><BQ></P>







<P>As you know, <I>stored procedures</I> are encapsulated business rules



or procedures that reside in the database server. They also enforce uniformity



across applications, as well as provide security to the database access.



Stored procedures last beyond the execution of the program. So, the application



program does not spend any time waiting for the DBMS to create the execution



plan.</P>







<P></BQ></P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>



</BLOCKQUOTE>







<P>Now look at each type of statement more closely and see what each has



to offer a Java program.</P>







<H3><A NAME="I9"></A><A NAME="I10"></A><B><I>statement</I></B></H3>







<P>A <TT><FONT COLOR="#238E23">Statement</FONT></TT> object is created



using the <TT><FONT COLOR="#238E23">createStatement()</FONT></TT> method



in the <TT><FONT COLOR="#238E23">Connection</FONT></TT> object. Table 46.1



shows all methods available for the <TT><FONT COLOR="#238E23">Statement</FONT></TT>



object.</P>







<P><I>Table 46.1 Statement Object Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>ResultSet</TD>







<TD>executeQuery</TD>







<TD>(String sql)</TD>



</TR>







<TR>



<TD>int</TD>







<TD>executeUpdate</TD>







<TD>(String sql)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>execute</TD>







<TD>(String sql)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>getMoreResults</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>close</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getMaxFieldSize</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setMaxFieldSize</TD>







<TD>(int max)</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getMaxRows</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setMaxRows</TD>







<TD>(int max)</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setEscapeProcessing</TD>







<TD>(boolean enable)</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getQueryTimeout</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setQueryTimeout</TD>







<TD>(int seconds)</TD>



</TR>







<TR>



<TD>void</TD>







<TD>cancel</TD>







<TD>()</TD>



</TR>







<TR>



<TD>java.sql.SQLWarning</TD>







<TD>getWarnings</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>clearWarnings</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setCursorName</TD>







<TD>(String name)</TD>



</TR>







<TR>



<TD>ResultSet</TD>







<TD>getResultSet</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getUpdateCount</TD>







<TD>()</TD>



</TR>



</TABLE>







<P>The most important methods are <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT>,



<TT><FONT COLOR="#238E23">executeUpdate()</FONT></TT>, and <TT><FONT COLOR="#238E23">execute()</FONT></TT>.



As you create a Statement object with a <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statement, the <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT> method



takes a SQL string. It passes the SQL string to the underlying data source



through the driver manager and gets the ResultSet back to the application



program. The <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT> method



returns only one ResultSet. For those cases that return ere more than one



ResultSet, the <TT><FONT COLOR="#238E23">execute()</FONT></TT> method should



be used.</P>







<BLOCKQUOTE>



<P><IMG SRC="caution.gif" HEIGHT=35 WIDTH=400></P>







<P><BQ></P>







<P>Only one ResultSet can be opened per <TT><FONT COLOR="#238E23">Statement</FONT></TT>



object at one time.</P>







<P></BQ></P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>



</BLOCKQUOTE>







<P>For <TT><FONT COLOR="#238E23">SQL</FONT></TT> statements that do not



return a ResultSet like the <TT><FONT COLOR="#238E23">UPDATE</FONT></TT>,



<TT><FONT COLOR="#238E23">DELETE</FONT></TT>, and <TT><FONT COLOR="#238E23">DDL</FONT></TT>



statements, the <TT><FONT COLOR="#238E23">Statement</FONT></TT> object



has the <TT><FONT COLOR="#238E23">executeUpdate()</FONT></TT> method that



takes a SQL string and returns an integer. This integer indicates the number



of rows that are affected by the SQL statement.</P>







<BLOCKQUOTE>



<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>







<P><BQ></P>







<P>The JDBC processing is synchronous; that is, the application program



must wait for the <TT><FONT COLOR="#238E23">SQL</FONT></TT> statements



to complete. But because Java is a multithreaded platform, the JDBC designers



suggest using threads to simulate asynchronous processing.</P>







<P></BQ></P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>



</BLOCKQUOTE>







<P>The <TT><FONT COLOR="#238E23">Statement</FONT></TT> object is best suited



for ad hoc SQL statements or <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statements that are executed once. The DBMS goes through the syntax run,



query plan optimization and the execution plan generation stages as soon



as this SQL statement is received. The DBMS executes the query and then



discards the optimized execution plan. So, if the <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT>



method is called again, the DBMS goes through all of the steps again.</P>







<P>The following example program shows how to use the S<TT><FONT COLOR="#238E23">tatement</FONT></TT>



class to access a database.</P>







<BLOCKQUOTE>



<P><IMG SRC="crossref.gif" HEIGHT=35 WIDTH=400></P>







<P><BQ></P>







<P><A NAME="I11"></A>See "Anatomy of a JDBC Application," [<A HREF="44javafi.htm">ch.



44</A>]</P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>







<P></BQ></P>



</BLOCKQUOTE>







<P>In this example, you will list all of the subjects (classes) available



in the enrollment database and their location and Day and times. The SQL



statement for this is </P>







<P><TT><FONT COLOR="#238E23">SELECT ClassName, Location, DaysAndTimes FROM



Classes</FONT></TT></P>







<P>You create a <TT><FONT COLOR="#238E23">Statement</FONT></TT> object



and pass the SQL string during the <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT>



method call to get this data.</P>







<PRE><TT><FONT COLOR="#238E23">   //Declare a method and some variables.



   public void ListClasses() throws SQLException {



int i, NoOfColumns;



String ClassName,ClassLocation, ClassSchedule;



      //Initialize and load the JDBC-ODBC driver.



Class.forName (&quot;jdbc.odbc.JdbcOdbcDriver&quot;);



      //Make the connection object.



Connection Ex1Con = DriverManager.getConnection( &quot;jdbc:odbc:StudentDB;uid="admin";pw="sa");



//Create a simple Statement object.



Statement Ex1Stmt = Ex1Con.createStatement();



//Make a SQL string, pass it to the DBMS, and execute the SQL statement.



ResultSet Ex1rs = Ex1Stmt.executeQuery(



 &quot;SELECT ClassName, Location, DaysAndTimes FROM Classes&quot;);



//Process each row until there are no more rows.



// And display the results on the console.



System.out.println("Class         Location      Schedule");



while (Ex1rs.next()) {



// Get the column values into Java variables



ClassName = Ex1rs.getString(1);



ClassLocation = Ex1rs.getString(2);



ClassSchedule = Ex1rs.getString(3);



System.out.println(ClassName,ClassLocation,ClassSchedule);



}



}</FONT></TT></PRE>







<P>As you can see, the program is very straight forward. You do the initial



connection and create a <TT><FONT COLOR="#238E23">Statement</FONT></TT>



object. You pass the SQL along with the method <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT>



call. The driver passes the SQL string to the DBMS which performs the query



and returns the results. After the statement is finished, the optimized



execution plan is lost.</P>







<H3><A NAME="I12"></A><A NAME="I13"></A><B><I>PreparedStatement</I></B></H3>







<P>In the case of a <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



object, as the name implies, the application program prepares a <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statement using the <TT><FONT COLOR="#238E23">java.sql.Connection.prepareStatement()</FONT></TT>



method. The <TT><FONT COLOR="#238E23">PreparedStatement()</FONT></TT> method



takes a SQL string, which is passed to the underlying DBMS. The DBMS goes



through the syntax run, query plan optimization, and the execution plan



generation stages but does not execute the SQL statement. Possibly, it



returns a handle to the optimized execution plan that the JDBC driver stores



internally in the <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



object. </P>







<P>The methods of the <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



object are shown in table 46.2. Notice that the <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT>,



<TT><FONT COLOR="#238E23">executeUpdate()</FONT></TT>, and <TT><FONT COLOR="#238E23">execute()</FONT></TT>



methods do not take any parameters. They are just calls to the underlying



DBMS to perform the already optimized SQL statement.</P>







<P><I>Table 46.2 </I>PreparedStatement<I> Object Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>ResultSet</TD>







<TD>executeQuery</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>executeUpdate</TD>







<TD>()</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>execute</TD>







<TD>()</TD>



</TR>



</TABLE>







<P>One of the major feature of a <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



is that it can handle IN types of parameters. The parameters are indicated



in a <TT><FONT COLOR="#238E23">SQL</FONT></TT> statement by placing the



<B>?</B> as the parameter marker instead of the actual values. In the Java



program, the association is made to the parameters with the <TT><FONT COLOR="#238E23">setXXXX()</FONT></TT>



methods, as shown in table 46.3. All of the <TT><FONT COLOR="#238E23">setXXXX()</FONT></TT>



methods take the parameter index, which is 1 for the first "?," 2 for the



second "?," and so on.</P>







<P><I>Table 46.3 </I>java.sql.PreparedStatement<I>-Parameter-Related Methods.</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD COLSPAN=2><B>Method Name</B></TD>







<TD COLSPAN=2><B>Parameter</B></TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>clearParameters</TD>







<TD COLSPAN=2>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setAsciiStream</TD>







<TD COLSPAN=2>(int parameterIndex, java.io.InputStream x, int length)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setBinaryStream</TD>







<TD COLSPAN=2>(int parameterIndex, java.io.InputStream x, int length)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setBoolean</TD>







<TD COLSPAN=2>(int parameterIndex, boolean x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setByte</TD>







<TD COLSPAN=2>(int parameterIndex, byte x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setBytes</TD>







<TD COLSPAN=2>(int parameterIndex, byte x[])</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setDate</TD>







<TD COLSPAN=2>(int parameterIndex, java.sql.Date x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setDouble</TD>







<TD COLSPAN=2>(int parameterIndex, double x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setFloat</TD>







<TD COLSPAN=2>(int parameterIndex, float x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setInt</TD>







<TD COLSPAN=2>(int parameterIndex, int x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setLong</TD>







<TD COLSPAN=2>(int parameterIndex, long x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setNull</TD>







<TD COLSPAN=2>(int parameterIndex, int sqlType)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setNumeric</TD>







<TD COLSPAN=2>(int parameterIndex, Numeric x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setShort</TD>







<TD COLSPAN=2>(int parameterIndex, short x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setString</TD>







<TD COLSPAN=2>(int parameterIndex, String x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setTime</TD>







<TD COLSPAN=2>(int parameterIndex, java.sql.Time x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setTimestamp</TD>







<TD COLSPAN=2>(int parameterIndex, java.sql.Timestamp x)</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>setUnicodeStream</TD>







<TD COLSPAN=2>(int parameterIndex, java.io.InputStream x, int length)</TD>



</TR>







<TR>



<TD COLSPAN=5>



<CENTER><P><I>Advanced Features-Object Manipulation</I></P></CENTER>



</TD>



</TR>







<TR>



<TD COLSPAN=2><B>Return Type</B></TD>







<TD COLSPAN=2><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD COLSPAN=2>void</TD>







<TD COLSPAN=2>setObject</TD>







<TD>(int parameterIndex, Object x, int targetSqlType, int scale)</TD>



</TR>







<TR>



<TD COLSPAN=2>void</TD>







<TD COLSPAN=2>setObject</TD>







<TD>(int parameterIndex, Object x, int targetSqlType)</TD>



</TR>







<TR>



<TD COLSPAN=2>void</TD>







<TD COLSPAN=2>setObject</TD>







<TD>(int parameterIndex, Object x)</TD>



</TR>



</TABLE>







<P>In the case of the <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>,



the driver actually sends only the execution plan ID and the parameters



to the DBMS. This results in less network traffic and is well-suited for



Java applications on the Internet. The <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



should be used when you need to execute the <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statement many times in a Java application. But remember, even though the



optimized execution plan is available during the execution of a Java program,



the DBMS discards the execution plan at the end of the program. So, the



DBMS must go through all of the steps of creating an execution plan every



time the program runs. The <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



object achieves faster SQL execution performance than the simple <TT><FONT COLOR="#238E23">Statement</FONT></TT>



object, as the DBMS does not have to run through the steps of creating



the execution plan.</P>







<P>The following example program shows how to use the <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



class to access a database. The database schema is shown in Chapter 44.



In this example, you optimize the example you developed in the Statement



example.</P>







<BLOCKQUOTE>



<P><IMG SRC="crossref.gif" HEIGHT=35 WIDTH=400></P>







<P><BQ></P>







<P>See "Anatomy of a JDBC Application," [<A HREF="44javafi.htm">Ch.44</A>]</P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>







<P></BQ></P>



</BLOCKQUOTE>







<P>The simple Statement example can be improved in a few major ways. First,



the DBMS goes through building the execution plan every time. So you make



it a <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>. Secondly,



the query lists all courses which could scroll away. You improve this situation



by building a parametrized query as follows: </P>







<PRE><TT><FONT COLOR="#238E23">   //Declare class variables



Connection Con;



PreparedStatement PrepStmt;



boolean Initialized = false;



   private void InitConnection() throws SQLException {



      //Initialize and load the JDBC-ODBC driver.



Class.forName (&quot;jdbc.odbc.JdbcOdbcDriver&quot;);



      //Make the connection object.



Con = DriverManager.getConnection( &quot;jdbc:odbc:StudentDB;uid="admin";pw="sa");



//Create a prepared Statement object.



PrepStmt = Ex1Con.prepareStatement(



 &quot;SELECT ClassName, Location, DaysAndTimes FROM Classes WHERE ClassName = ?&quot;);



Initialized = True;



}



   public void ListOneClass(String ListClassName) throws SQLException {



int i, NoOfColumns;



String ClassName,ClassLocation, ClassSchedule;



      if (! Initialized) {



InitConnection();



}



// Set the SQL parameter to the one passed into this method



PrepStmt.setString(1,ListClassName);



ResultSet Ex1rs = PrepStmt.executeQuery()



//Process each row until there are no more rows and 



// display the results on the console.



System.out.println("Class         Location      Schedule");



while (Ex1rs.next()) {



// Get the column values into Java variables



ClassName = Ex1rs.getString(1);



ClassLocation = Ex1rs.getString(2);



ClassSchedule = Ex1rs.getString(3);



System.out.println(ClassName,ClassLocation,ClassSchedule);



}



}</FONT></TT></PRE>







<P>Now, if a student wants to check the details of one subject interactively,



this example program can be used. You can save execution time and network



traffic from the second invocation onwards because you are using the <TT><FONT COLOR="#238E23">PreparedStatement</FONT></TT>



object.</P>







<H3><A NAME="I14"></A><A NAME="I15"></A><B><I>CallableStatement</I></B></H3>







<P>For a secure, consistent, and manageable multi-tier client/server system,



the data access should allow the use of stored procedures. Stored procedures



centralize the business logic in terms of manageability and also in terms



of running the query. Java applets running on clients with limited resources



cannot be expected to run huge queries. But the results are important to



those clients. JDBC allows the use of stored procedures by the <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT>



class and with the escape clause string.</P>







<P>A <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT> object is



created by the <TT><FONT COLOR="#238E23">prepareCall()</FONT></TT> method



in the <TT><FONT COLOR="#238E23">Connection</FONT></TT> object. The <TT><FONT COLOR="#238E23">prepareCall()</FONT></TT>



method takes a string as the parameter. This string, called an <I>escape



clause</I>, is of the form</P>







<PRE><TT><FONT COLOR="#238E23">{[? =] call &lt;<I>stored procedure name</I>&gt; [&lt;<I>parameter</I>&gt;,&lt;<I>parameter</I>&gt; ...]}</FONT></TT></PRE>







<P>The <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT> class supports



parameters. These parameters are of the <TT><FONT COLOR="#238E23">OUT</FONT></TT>



kind from a stored procedure or the IN kind to pass values into a stored



procedure. The parameter marker (question mark) must be used for the return



value (if any) and any output arguments because the parameter marker is



bound to a program variable in the stored procedure. Input arguments can



be either literals or parameters. For a dynamic parameterized statement,



the escape clause string takes the form</P>







<P><TT><FONT COLOR="#238E23">{[? =] call &lt;<I>stored procedure name</I>&gt;



[&lt;?&gt;,&lt;?&gt; ...]}</FONT></TT></P>







<P>The OUT parameters should be registered using the <TT><FONT COLOR="#238E23">registerOutparameter()</FONT></TT>



method-as shown in table 46.4-before the call to the <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT>,



<TT><FONT COLOR="#238E23">executeUpdate()</FONT></TT>, or <TT><FONT COLOR="#238E23">execute()</FONT></TT>



methods.</P>







<P><I>Table 46.4 CallableStatement-</I>OUT<I> Parameter Register Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>void</TD>







<TD>registerOutParameter</TD>







<TD>(int parameterIndex, int sqlType) </TD>



</TR>







<TR>



<TD>void </TD>







<TD>registerOutParameter</TD>







<TD>(int parameterIndex, int sqlType, int scale) </TD>



</TR>



</TABLE>







<P>After the stored procedure is executed, the DBMS returns the result



value to the JDBC driver. This return value is accessed by the Java program



using the methods in table 46.5.</P>







<P><I>Table 46.5 </I>CallableStatement<I> Parameter Access Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>boolean </TD>







<TD>getBoolean</TD>







<TD>(int parameterIndex)</TD>



</TR>







<TR>



<TD>byte</TD>







<TD>getByte</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>byte[]</TD>







<TD>getBytes</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>java.sql.Date</TD>







<TD>getDate</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>double</TD>







<TD>getDouble</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>float</TD>







<TD>getFloat</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>int</TD>







<TD>getInt</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>long</TD>







<TD>getLong</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>getNumeric</TD>







<TD>(int parameterIndex, int scale) </TD>



</TR>







<TR>



<TD>Object</TD>







<TD>getObject</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>short</TD>







<TD>getShort</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>String </TD>







<TD>getString</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>java.sql.Time</TD>







<TD>getTime</TD>







<TD>(int parameterIndex) </TD>



</TR>







<TR>



<TD>java.sql.Timestamp</TD>







<TD>getTimestamp</TD>







<TD>(int parameterIndex)</TD>



</TR>







<TR>



<TD COLSPAN=3>



<CENTER><P><I>Miscellaneous Functions</I></P></CENTER>



</TD>



</TR>







<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>wasNull</TD>







<TD>()</TD>



</TR>



</TABLE>







<P><A NAME="I16"></A>If a student wants to find out the grades for a subject,



in the database schema shown in Chapter 44, you need to do many operations



on various tables, such as find all assignments for the student, match



them with class name, calculate grade points, and so on. This is a business



logic well suited for a stored procedure. In this example, you give the



stored procedure a student ID and class ID, and it returns the grade. Your



client program becomes simple, and all the processing is done at the server.



This is where you will use a <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT>.



</P>







<P>The stored procedure is call is of the form </P>







<P><TT><FONT COLOR="#238E23">studentGrade = getStudentGrade(<I>StudentID</I>,<I>ClassID</I>)</FONT></TT></P>







<P>In the JDBC call, you create a <TT><FONT COLOR="#238E23">CallableStatement</FONT></TT>



object with the "?" symbol as placeholders for parameters, and then connect



Java variables to the parameters as shown in the following example:</P>







<PRE><TT><FONT COLOR="#238E23">   public void DisplayGrade(String StudentID, String ClassID) throws SQLException {



int Grade;



      //Initialize and load the JDBC-ODBC driver.



Class.forName (&quot;jdbc.odbc.JdbcOdbcDriver&quot;);



      //Make the connection object.



Connection Con = DriverManager.getConnection( &quot;jdbc:odbc:StudentDB;uid="admin";pw="sa");



//Create a Callable Statement object.



CallableStatement CStmt = Con.prepareCall({?=call getStudentGrade[?,?]});



// Now tie the placeholders with actual parameters.



// Register the return value from the stored procedure



// as an integer type so that the driver knows how to handle it.



// Note the type is defined in the java.sql.Types.



CStmt.registerOutParameter(1,java.sql.Types.INTEGER);



// Set the In parameters (which are inherited from the PreparedStatement class)



CStmt.setString(1,StudentID);



CStmt.setString(2,ClassID);



// Now we are ready to call the stored procedure



int RetVal = CStmt.executeUpdate();



// Get the OUT parameter from the registered parameter



// Note that we get the result from the CallableStatement object



Grade = CStmt.getInt(1);



// And display the results on the console.



System.out.println(" The Grade is : ");



System.out.println(Grade);



}</FONT></TT></PRE>







<P>As you can see, JDBC has minimized the complexities of getting results



from a stored procedure. It still is a little involved, but is simpler.



May be in the future, these steps will become more simpler.</P>







<P>Now that you have seen how to communicate with the underlying DBMS with



SQL, let's see what you need to do to process the results sent back from



the database as a result of the <TT><FONT COLOR="#238E23">SQL</FONT></TT>



statements.</P>







<H2><A NAME="I17"></A><A NAME="I18"></A><B>ResultSet Processing: Retrieving



Results</B></H2>







<P>The <TT><FONT COLOR="#238E23">ResultSet</FONT></TT> object is actually



a tubular data set; that is, it consists of rows of data organized in uniform



columns. In JDBC, the Java program can see only one row of data at one



time. The program uses the <TT><FONT COLOR="#238E23">next()</FONT></TT>



method to go to the next row. JDBC does not provide any methods to move



backwards along the <TT><FONT COLOR="#238E23">ResultSet</FONT></TT> or



to remember the row positions (called <I>bookmarks</I> in ODBC). Once the



program has a row, it can use the positional index (1 for the first column,



2 for the second column, and so on) or the column name to get the field



value by using the <TT><FONT COLOR="#238E23">getXXXX()</FONT></TT> methods.



Table 46.6 shows the methods associated with the <TT><FONT COLOR="#238E23">ResultSet</FONT></TT>



object.</P>







<P><I>Table 46.6 </I>java.sql.ResultSet<I> Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD COLSPAN=2><B>Method Name</B></TD>







<TD COLSPAN=2><B>Parameter</B></TD>



</TR>







<TR>



<TD>boolean</TD>







<TD COLSPAN=2>next</TD>







<TD COLSPAN=2>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD COLSPAN=2>close</TD>







<TD COLSPAN=2>()</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD COLSPAN=2>wasNull</TD>







<TD COLSPAN=2>()</TD>



</TR>







<TR>



<TD COLSPAN=5>



<CENTER><P><I>Get Data By Column Position</I></P></CENTER>



</TD>



</TR>







<TR>



<TD COLSPAN=2><B>Return Type</B></TD>







<TD COLSPAN=2><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD COLSPAN=2>java.io.InputStream</TD>







<TD COLSPAN=2>getAsciiStream</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.io.InputStream</TD>







<TD COLSPAN=2>getBinaryStream</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>boolean</TD>







<TD COLSPAN=2>getBoolean</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>byte</TD>







<TD COLSPAN=2>getByte</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>byte[]</TD>







<TD COLSPAN=2>getBytes</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Date</TD>







<TD COLSPAN=2>getDate</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>double</TD>







<TD COLSPAN=2>getDouble</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>float</TD>







<TD COLSPAN=2>getFloat</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>int</TD>







<TD COLSPAN=2>getInt</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>long</TD>







<TD COLSPAN=2>getLong</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Numeric</TD>







<TD COLSPAN=2>getNumeric</TD>







<TD>(int columnIndex, int scale)</TD>



</TR>







<TR>



<TD COLSPAN=2>Object</TD>







<TD COLSPAN=2>getObject</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>short</TD>







<TD COLSPAN=2>getShort</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>String</TD>







<TD COLSPAN=2>getString</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Time</TD>







<TD COLSPAN=2>getTime</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Timestamp</TD>







<TD COLSPAN=2>getTimestamp</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.io.InputStream</TD>







<TD COLSPAN=2>getUnicodeStream</TD>







<TD>(int columnIndex)</TD>



</TR>







<TR>



<TD COLSPAN=5>



<CENTER><P><I>Get Data By Column Name</I></P></CENTER>



</TD>



</TR>







<TR>



<TD COLSPAN=2><B>Return Type</B></TD>







<TD COLSPAN=2><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD COLSPAN=2>java.io.InputStream</TD>







<TD COLSPAN=2>getAsciiStream</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.io.InputStream</TD>







<TD COLSPAN=2>getBinaryStream</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>boolean</TD>







<TD COLSPAN=2>getBoolean</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>byte</TD>







<TD COLSPAN=2>getByte</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>byte[]</TD>







<TD COLSPAN=2>getBytes</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Date</TD>







<TD COLSPAN=2>getDate</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>double</TD>







<TD COLSPAN=2>getDouble</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>float</TD>







<TD COLSPAN=2>getFloat</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>int</TD>







<TD COLSPAN=2>getInt</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>long</TD>







<TD COLSPAN=2>getLong</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Numeric</TD>







<TD COLSPAN=2>getNumeric</TD>







<TD>(String columnName, int scale)</TD>



</TR>







<TR>



<TD COLSPAN=2>Object</TD>







<TD COLSPAN=2>getObject</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>short</TD>







<TD COLSPAN=2>getShort</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>String</TD>







<TD COLSPAN=2>getString</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Time</TD>







<TD COLSPAN=2>getTime</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.sql.Timestamp</TD>







<TD COLSPAN=2>getTimestamp</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>java.io.InputStream</TD>







<TD COLSPAN=2>getUnicodeStream</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>int</TD>







<TD COLSPAN=2>findColumn</TD>







<TD>(String columnName)</TD>



</TR>







<TR>



<TD COLSPAN=2>SQLWarning</TD>







<TD COLSPAN=2>getWarnings</TD>







<TD>()</TD>



</TR>







<TR>



<TD COLSPAN=2>void</TD>







<TD COLSPAN=2>clearWarnings</TD>







<TD>()</TD>



</TR>







<TR>



<TD COLSPAN=2>String</TD>







<TD COLSPAN=2>getCursorName</TD>







<TD>()</TD>



</TR>







<TR>



<TD COLSPAN=2>ResultSetMetaData</TD>







<TD COLSPAN=2>getMetaData</TD>







<TD>()</TD>



</TR>



</TABLE>







<P>As you can see, the <TT><FONT COLOR="#238E23">ResultSet</FONT></TT>



methods-even though there are many-are very simple. The major ones are



the <TT><FONT COLOR="#238E23">getXXX()</FONT></TT> methods. The <TT><FONT COLOR="#238E23">getMetaData()</FONT></TT>



method returns the meta data information about a ResultSet. The DatabaseMetaData



also returns the results in the ResultSet form. The ResultSet also has



methods for the silent SQLWarnings. It is a good practice to check any



warnings using the <TT><FONT COLOR="#238E23">getWarning()</FONT></TT> method



that returns a null if there are no warnings.</P>







<H2><A NAME="I19"></A><A NAME="I20"></A><B>Other JDBC Classes</B></H2>







<P>Now that you have seen all of the main database-related classes, let



us look at some of the supporting classes that are available in JDBC. These



classes include the <TT><FONT COLOR="#238E23">Date</FONT></TT>, <TT><FONT COLOR="#238E23">Time</FONT></TT>,



<TT><FONT COLOR="#238E23">TimeStamp</FONT></TT>, <TT><FONT COLOR="#238E23">Numeric</FONT></TT>,



and so on. Most of these classes extend the basic Java classes to add capability



to handle and translate data types that are specific to SQL.</P>







<H3><A NAME="I21"></A><A NAME="I22"></A><B><I>java.sql.Date</I></B></H3>







<P>This package gives a Java program the capability to handle SQL <TT><FONT COLOR="#238E23">DATE</FONT></TT>



information with only year, month, and day values. This package contrasts



with the <TT><FONT COLOR="#238E23">java.util.Date</FONT></TT>, where the



time in hours, minutes, and seconds is also kept.</P>







<P><I>Table 46.7 </I>java.sql.Date<I> Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>Date</TD>







<TD>Date</TD>







<TD>(int year, int month, int day)</TD>



</TR>







<TR>



<TD>Date </TD>







<TD>valueOf</TD>







<TD>(String s)</TD>



</TR>







<TR>



<TD>String</TD>







<TD>toString</TD>







<TD>()</TD>



</TR>



</TABLE>







<H3><A NAME="I23"></A><A NAME="I24"></A><B><I>java.sql.Time</I></B></H3>







<P>As seen in table 46.8, the java.sql.Time adds the <TT><FONT COLOR="#238E23">Time</FONT></TT>



object to the <TT><FONT COLOR="#238E23">java.util.Date</FONT></TT> package



to handle only hours, minutes, and seconds. <TT><FONT COLOR="#238E23">java.sql.Time</FONT></TT>



is also used to represent SQL <TT><FONT COLOR="#238E23">TIME</FONT></TT>



information.</P>







<P><I>Table 46.8 </I>java.sql.Time<I> Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>Time</TD>







<TD>Time</TD>







<TD>(int hour, int minute, int second)</TD>



</TR>







<TR>



<TD>Time</TD>







<TD>Time</TD>







<TD>valueOf(String s)</TD>



</TR>







<TR>



<TD>String</TD>







<TD>toString</TD>







<TD>()</TD>



</TR>



</TABLE>







<H3><A NAME="I25"></A><A NAME="I26"></A><B><I>java.sql.Timestamp</I></B></H3>







<P>The <TT><FONT COLOR="#238E23">java.sql.Timestamp</FONT></TT> package



adds the <TT><FONT COLOR="#238E23">TimeStamp</FONT></TT> class to the <TT><FONT COLOR="#238E23">java.util.Date</FONT></TT>



package. It adds the capability of handling nanoseconds. But the granularity



of the subsecond timestamp depends on the database field as well as the



operating system.</P>







<P><B>Table 46.9 <I>java.sql.Timestamp</I> Methods</B></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>TimeStamp</TD>







<TD>TimeStamp</TD>







<TD>(int year, int month, int date, int hour, int minute, int second, int



nano); </TD>



</TR>







<TR>



<TD>TimeStamp</TD>







<TD>valueOf</TD>







<TD>(String s)</TD>



</TR>







<TR>



<TD>String</TD>







<TD>toString</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getNanos</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setNanos</TD>







<TD>(int n)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>equals</TD>







<TD>(TimeStamp ts)</TD>



</TR>



</TABLE>







<H3><A NAME="I27"></A><A NAME="I28"></A><B><I>java.sql.Types</I></B></H3>







<P>This class defines a set of <TT><FONT COLOR="#238E23">XOPEN</FONT></TT>



equivalent integer constants that identify SQL types. The constants are



final types. Therefore, they cannot be redefined in applications or applets.



Table 46.10 lists the constant names and their values.</P>







<P><I>Table 46.10 </I>java.sql.Types<I> constants</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Constant Name</B></TD>







<TD><B>Value</B></TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">BIGINT</FONT></TT></TD>







<TD>-5</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">BINARY</FONT></TT></TD>







<TD>-2</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">BIT</FONT></TT></TD>







<TD>-7</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">CHAR</FONT></TT></TD>







<TD>1</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">DATE</FONT></TT></TD>







<TD>91</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">DECIMAL</FONT></TT></TD>







<TD>3</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">DOUBLE</FONT></TT></TD>







<TD>8</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">FLOAT</FONT></TT></TD>







<TD>6</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">INTEGER</FONT></TT></TD>







<TD>4</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">LONGVARBINARY</FONT></TT></TD>







<TD>-4</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">LONGVARCHAR</FONT></TT></TD>







<TD>-1</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">NULL</FONT></TT></TD>







<TD>0</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">NUMERIC</FONT></TT></TD>







<TD>2</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">OTHER</FONT></TT></TD>







<TD>1111</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">REAL</FONT></TT></TD>







<TD>7</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">SMALLINT</FONT></TT> </TD>







<TD>5</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">TIME</FONT></TT></TD>







<TD>92</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">TIMESTAMP</FONT></TT></TD>







<TD>93</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">TINYINT</FONT></TT></TD>







<TD>-6</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">VARBINARY</FONT></TT></TD>







<TD>-3</TD>



</TR>







<TR>



<TD><TT><FONT COLOR="#238E23">VARCHAR</FONT></TT></TD>







<TD>12</TD>



</TR>



</TABLE>







<H3><A NAME="I29"></A><A NAME="I30"></A><B><I>java.sql.Numeric</I></B></H3>







<P>The <TT><FONT COLOR="#238E23">java.sql.Numeric</FONT></TT> class adds



the capability of representing SQL fixed-point <TT><FONT COLOR="#238E23">NUMERIC</FONT></TT>



and <TT><FONT COLOR="#238E23">DECIMAL</FONT></TT> values to the <TT><FONT COLOR="#238E23">java.lang.Number</FONT></TT>



class. The <TT><FONT COLOR="#238E23">Numeric</FONT></TT> objects are defined



in terms of four factors: </P>







<UL>



<LI>Precision</LI>







<LI>Scale</LI>







<LI>Sign</LI>







<LI>Value</LI>



</UL>







<P>The precision is the total number of digits in a <TT><FONT COLOR="#238E23">Numeric</FONT></TT>



object. The Scale is the number of digits to the right of the decimal point.



The <TT><FONT COLOR="#238E23">Numeric</FONT></TT> class is a final class



and, therefore, cannot be redefined. This class provides complete arithmetic



operations as well as equality comparisons. <TT><FONT COLOR="#238E23">Conversion</FONT></TT>



methods to the basic types are also provided. The following tables list



the methods for the <TT><FONT COLOR="#238E23">Numeric</FONT></TT> class.</P>







<P><I>Table 46.11 </I>java.sql.Numeric<I> Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>int</TD>







<TD>getRoundingValue</TD>







<TD>()</TD>



</TR>







<TR>



<TD>void</TD>







<TD>setRoundingValue</TD>







<TD>(int val)</TD>



</TR>







<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>createFromScaled</TD>







<TD>(long scaled, int s)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(String s)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(String s,int scale)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(int x,int scale)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(double x, int scale)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(Numeric x, int scale)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(int x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>Numeric</TD>







<TD>(long x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>createFromByteArray</TD>







<TD>(byte byteArray[])</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>createFromIntegerArray</TD>







<TD>(int intArray[])</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>createFromRadixString</TD>







<TD>(String s, index radix)</TD>



</TR>







<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>add</TD>







<TD>(Numeric n)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>divide</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>equals</TD>







<TD>(Object obj)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>greaterThan</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>greaterThanOrEquals</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>lessThan</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>lessThanOrEquals</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>multiply</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>subtract</TD>







<TD>(Numeric n)</TD>



</TR>







<TR>



<TD>int</TD>







<TD>hashCode</TD>







<TD>()</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>setScale</TD>







<TD>(int scale)</TD>



</TR>







<TR>



<TD>double</TD>







<TD>doubleValue</TD>







<TD>()</TD>



</TR>







<TR>



<TD>float</TD>







<TD>floatValue</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getScale</TD>







<TD>()</TD>



</TR>







<TR>



<TD>long</TD>







<TD>getScaled</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>intValue</TD>







<TD>()</TD>



</TR>







<TR>



<TD>long</TD>







<TD>longValue</TD>







<TD>()</TD>



</TR>







<TR>



<TD>String</TD>







<TD>toString</TD>







<TD>()</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>random</TD>







<TD>(int bits, Random rnd)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>integerDivide</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>remainder</TD>







<TD>(Numeric x)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>sqrt</TD>







<TD>()</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>pow</TD>







<TD>(int e)</TD>



</TR>







<TR>



<TD>int</TD>







<TD>significantBits</TD>







<TD>()</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>shiftRight</TD>







<TD>(int shiftBits)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>shiftLeft</TD>







<TD>(int shiftBits)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>modInverse</TD>







<TD>(Numeric mod)</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>modExp</TD>







<TD>(Numeric exponent, </TD>



</TR>







<TR>



<TD></TD>







<TD></TD>







<TD>Numeric mod)</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>isProbablePrime</TD>







<TD>()</TD>



</TR>







<TR>



<TD>Numeric</TD>







<TD>pi</TD>







<TD>(int numOfPlaces)</TD>



</TR>







<TR>



<TD>String</TD>







<TD>toString</TD>







<TD>(int Radix)</TD>



</TR>



</TABLE>







<H3><A NAME="I31"></A><A NAME="I32"></A><B><I>java.sql.DataTruncation</I></B></H3>







<P>This class provides methods for getting details when a DataTruncation



warning or exception is thrown by a SQL statement. The data truncation



could happen to a column value or parameter.</P>







<P>The main elements of a <TT><FONT COLOR="#238E23">DataTruncation</FONT></TT>



object are:</P>







<UL>



<LI><I>Index</I>. Gives the column or parameter number.</LI>







<LI><TT><FONT COLOR="#238E23">parameter</FONT></TT> <I>flag</I>. True if



the truncation is on a parameter and false if the truncation is on a column.</LI>







<LI><TT><FONT COLOR="#238E23">read</FONT></TT> <I>flag</I>. True if the



truncation is during a read and false if the truncation is on a write.



</LI>



</UL>







<P>The <TT><FONT COLOR="#238E23">DataTruncation</FONT></TT> object also



consists of a datasize element that has the actual size (in bytes) of the



truncated value and the transfer size, which is the number of bytes actually



transferred. </P>







<P>The various methods as listed in table 46.12 let the Java program retrieve



the values of these elements. For example, the <TT><FONT COLOR="#238E23">getRead()</FONT></TT>



method returns true if data truncation occurred during a read and a false



if the truncation occurred during a write.</P>







<P><I>Table 46.12 </I>java.sql.DataTruncation<I> Methods</I></P>







<TABLE BORDER=1 >



<TR>



<TD><B>Return Type</B></TD>







<TD><B>Method Name</B></TD>







<TD><B>Parameter</B></TD>



</TR>







<TR>



<TD>int</TD>







<TD>getDataSize</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getIndex</TD>







<TD>()</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>getParameter</TD>







<TD>()</TD>



</TR>







<TR>



<TD>boolean</TD>







<TD>getRead</TD>







<TD>()</TD>



</TR>







<TR>



<TD>int</TD>







<TD>getTransferSize</TD>







<TD>()</TD>



</TR>



</TABLE>







<H2><A NAME="I33"></A><A NAME="I34"></A><B>JDBC in Perspective</B></H2>







<P>JDBC is an important step in the right direction to elevate the Java



language to the Java platform. The Java APIs-including the Enterprise APIs



(JDBC, RMI, Serialization, and IDL), Security APIs, and the Server APIs-are



the essential ingredients for developing enterprise-level, distributed,



multi-tier client/server applications.</P>







<P>The JDBC specification life cycle happened in the speed of the Net-one



Net year is widely clocked as equaling seven normal years. The version



1.0 JDBC specification is fixed, so the developers and driver vendors are



not chasing a moving target.</P>







<P>Another factor in favor of JDBC is its similarity to ODBC. JavaSoft



made the right decision to follow ODBC philosophy and abstractions, thus



making it easy for ISVs and users to leverage their ODBC experience and



existing ODBC drivers. In the JDBC specification, this goal is described



as "JDBC must be implementable on top of common database interfaces."</P>







<P>By making JDBC a part of the Java language, you received all of the



advantages of the Java language concepts for database access. Also, as



all implementers have to support the Java APIs, JDBC has become a universal



standard. This philosophy, stated in the JDBC specification as "provide



a Java interface that is consistent with the rest of the Java system,"



makes JDBC an ideal candidate for use in Java-based database development.</P>







<P>Another good design philosophy is the driver independence of the JDBC.



The underlying database drivers can either be native libraries-such as



a DLL for the Windows system or Java routines connecting to listeners.



The full Java implementation of JDBC is suitable for a variety of Network



and other Java OS computers, thus making JDBC a versatile set of APIs.</P>







<BLOCKQUOTE>



<P><IMG SRC="note.gif" HEIGHT=35 WIDTH=399></P>







<P><BQ></P>







<P>In my humble opinion, the most important advantage of JDBC is its simplicity



and versatility. The goal of the designers was to keep the API and common



cases simple and "support the weird stuff in separate interfaces." Also,



they wanted to use multiple methods for multiple functionality. They have



achieved their goals even in this first version. </P>







<P><BQ></P>







<P>For example, the <TT><FONT COLOR="#238E23">Statement</FONT></TT> object



has the <TT><FONT COLOR="#238E23">executeQuery()</FONT></TT> method for



<TT><FONT COLOR="#238E23">SQL</FONT></TT> statements returning rows of



data, and the <TT><FONT COLOR="#238E23">executeUpdate()</FONT></TT> method



for statements without data to return. Also, uncommon cases, such as statements



returning multiple ResultSets, have a separate method: <TT><FONT COLOR="#238E23">execute()</FONT></TT>.</P>







<P></BQ></BQ></P>







<P><IMG SRC="bottom.gif" HEIGHT=20 WIDTH=400></P>



</BLOCKQUOTE>







<P>As more applications are developed with JDBC and as the Java platform



matures, more and more features will be added to JDBC. One of the required



features, especially for client/server processing, is a more versatile



cursor. The current design leaves the cursor management details to the



driver. I would prefer more application-level control for scrollable cursors,



positioned update/delete capability, and so on. Another related feature



is the bookmark feature, which is useful especially in a distributed processing



environment such as the Internet.</P>







<br><hr><center><p> | <A href="44javafi.htm"> Previous Chapter </a> | <A href="index.htm"> Table of Contents </a> | <A href="46javafi.htm"> Next Chapter </a> | </p> </center></BODY>



</HTML>



